Method Enumerable#reduce provides functionality for 
reducing streams of sorted records (google "MapReduce").

Let's imaging container with records [key, count] containing 
records with same key.  Reducing several records with same key 
to one record can by done like this:

  [ [key, c1], [key, c2], [key, c3] ] #=> [key, c1 + c2 + c3]

There is the way to do it:

  records.sort.reduce{|a,b| (a||=0) + b}

Generaly speaking reducing is injecting values with same key.
The reduce operation is equivalent to two injects:
 
  records.inject(Hash.new{|h,k| h[k]=[]}).inject{|map,r| map[r[0]] << r.value; map}.
    map{|records,pair| pair[0], pair[1].inject{|a,b| (a||=0) + b}}

Reduce algorithm implementation is different from this inject-map-inject version.
It's simple and based on the fact, that input records are already grouped by key. 
 
Reduce can by combined with map, but before each reduce records should be sorted
(or grouped by) by key.

If one has records [phrase, frequency] and wants to get
records [word, frequency] he should run

 records.
   map{|phrase, frequency| phrase.split.map{|word| [word, frequency]}}.
   inject([]){|new_records, records| new_records.push(*records)}.
   sort.
   reduce{|a,b| (a||0) + b}

 
One can make calculations lazy just converting container to lazy one:
   records.to_lazy. ...
   
Lazy container allows dramatically redcue memory usage when using
and create piped transfromations: map, select, uniq and reduce.
  
The only problem is method +sort+, which requires all records to be 
loaded in memory. But one can use external sort:
  
  cat records.txt | \ 
    ruby -r reduce -e 'STDIN.to_lazy.map(&:to_record).each{|p,f| p.split.each{|w| puts [w,f].to_line}}' | \ 
    sort | \ 
    ruby -r reduce -e 'STDIN.to_lazy.map(&:to_record).reduce{|a,b| (a||0) + b.to_i}.each{|r| puts r.to_line}'

Method String#to_record is <tt>spit("\t")</tt>.

There are shortcuts: 
* <tt>records</tt> for <tt>STDIN.to_lazy.map(&:to_record)</tt>
* <tt>r.put_record</tt> for <tt>puts r.to_line</tt>

  cat records.txt | sort | \
  ruby -r reduce -e 'records.each{|p,f| p.split.each{|w| puts [w,f].to_line)' | \ 
  sort | \ 
  ruby -r reduce -e 'records.reduce{|a,b| (a||0) + b.to_i}.each(&:put_record)'

One can use pipe operator +|+, defined for LazyEnumerable
and put +sort+ command line inside ruby code:

  cat records.txt | ruby -r reduce -e \ 
  'records.each{|p,f| p.split.each{|w| puts [w,f].to_line}}.|("sort"). \ 
    reduce{|a,b| (a||0) + b.to_i}}).each(&:put_record)'

